[{"id":0,"href":"/how-to-set-up-git-and-github/","title":"How to set up Git and Github","section":"Tormod's Blog","content":"Git is a version control system created by Linus Torvalds, also known as the creator of Linux. He named Git after himself as he sees himself as an \u0026ldquo;egotistical bastard\u0026rdquo;, condensed into the word \u0026ldquo;git\u0026rdquo;.\nGit just allows you to track your system progress so that if something breaks you can always revert back to a previous save. Think of git like a save file in a video game.\nIn the project folder, type the following in the command line:\ngit init Initialises your project by creating a hidden git folder as well as a .gitignore file.\ngit status You can see the status of your committed/uncommitted files with git status. Doesn\u0026rsquo;t \u0026lsquo;do anything\u0026rsquo; but gives you some information about the process.\ngit add . Creates a snapshot of the current state of the files in your folder to be saved. You can add single files or folders by writing their names instead.\ngit commit -m \u0026#34;commit my commit message\u0026#34; Saves all the snapshotted files added. the \u0026ldquo;-m\u0026rdquo; allows you to write a short message explaining what the changes do. Common culture is to write in the imperative, ex \u0026ldquo;create nextjs app\u0026rdquo; rather than \u0026ldquo;i created a new nextjs app\u0026rdquo;.\ngit branch -M main Sets the name of your main branch to \u0026ldquo;main\u0026rdquo;, as is common practice for your main project branch. Branches are used so that you can make separate changes to a project without touching the\nNow, for adding github: # On your github account, create a new repository for your project. Run the following, switching out the link for your project link.\ngit remote add origin https://github.com/username/new-project.git Connects your local git to your remote github repository.\ngit push -U origin main Pushes your most recent commit to the github project with \u0026ldquo;git push\u0026rdquo; and sets the default remote branch(also called upstream branch) to the main branch.\nAfter this you only need to push with git push\n"},{"id":1,"href":"/twitter-neon-setup/","title":"Setting up twitter(x) login with NextAuth + neon database storage with Vercel","section":"Tormod's Blog","content":" Setting up NextAuth # To implement NextAuth on your website, first install Next-Auth\nnpm install next-auth \u0026mdash; Error message START, move to error message troubleshooting if encountered \u0026mdash; If you\u0026rsquo;re having problems here, it might be because your ICU4C library is outdated. What is ICU (bonus info)\nTo fix this, reinstall ICU\nbrew reinstall icu4c Link it\nbrew link icu4c --force \u0026mdash; Error message END \u0026mdash;\nOnce you have installed Next-Auth, create a .env.local file in your project\u0026rsquo;s root.\nIn project root, set up a secret token for NextAuth\nnpx auth secret This will put a NEXT_SECRET variable in your .env.local file. Add a NEXT_URL=\u0026ldquo;http://localhost:3000\u0026rdquo; variable.\nIn vercel put in your site where you will implement authentication. In your project, create the folders\napp/api/auth/[\u0026hellip;nextauth] [\u0026hellip;nextauth] is a catch-all dynamic route that handles any sub-routes under auth that processes requests for nextauth.js. Signing in users Signing out users Handling OAuth callbacks Refreshing tokens Accessing user session information Setting up Twitter authentication # Create a Twitter Developer Account Create a project, making sure to set the following settings: App permissions: Read and write Don\u0026rsquo;t request email from users Type of App: Web App, Automated App or Bot App info: Callback url http://localhost:3000/api/auth/callback/twitter any live site you want it on, ex. https://yoursite.com/api/auth/callback/twitter Website url Some site to identify you ToS If you want / if you collect user data Privacy policy If you want / If you collect user data Congrats, you now have API keys! Take note of the Client ID and Secret. You will need these. Set up a Neon Database with Vercel # On your Vercel project, go to storage and set up a free Neon database. Access the Neon console linked in your vercel project and go to the SQL Editor.\nCreate a table in your neon database by typing the below and running the code:\nCREATE TABLE comments ( id SERIAL PRIMARY KEY, content TEXT NOT NULL, username TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ); This will create a table called comments that will store the comment id, the content of any messages written included, the username and the time it was created.\nSet up Twitter Authentication Types # Define the Twitter profile structure Create a file called types.ts – this file will contain undefined types to satisfy typescript\nexport interface TwitterProfile { data: { id: string; name: string; username: string; // add any more here }; } Configure NextAuth with Twitter Provider # Create the authentification configuration\nin app/api/[\u0026hellip;nextauth]/route.ts:\nimport NextAuth, { type NextAuthOptions } from \u0026#34;next-auth\u0026#34;; import TwitterProvider from \u0026#34;next-auth/providers/twitter\u0026#34;; import { TwitterProfile } from \u0026#34;@/app/types/types\u0026#34;; // replace with wherever you put your types.ts file // 1. Extend NextAuth session to include Twitter username (and other) declare module \u0026#34;next-auth\u0026#34; { interface Session { user: { username?: string; name?: string | null; email?: string | null; image?: string | null; // any other }; } } // 2. Set up Twitter Provider const authOptions: NextAuthOptions = { providers: [ TwitterProvider({ clientId: process.env.TWITTER_CLIENT_ID as string, clientSecret: process.env.TWITTER_CLIENT_SECRET as string, version: \u0026#34;2.0\u0026#34;, // make sure you have configured your twitter dev project to be 2.0 authorization: { params: { scope: \u0026#34;users.read tweet.read offline.access\u0026#34;, } } }), ], callbacks: { // 3. Capture username during JWT creation async jwt({ token, profile }) { if (profile) { const twitterProfile = profile as TwitterProfile; token.username = twitterProfile.data.username; } return token; }, // 4. Add username to session async session({ session, token }) { if (session.user) { session.user.username = token.username as string; } return session; } } }; Create database operations # Create an actions.ts file to do database operations. I have added some optional comment features but you can do any other database actions using similar functions. Database operations (bonus info)(coming soon)\n\u0026#39;use server\u0026#39;; export async function createComment(comment: string, twitterHandle: string) { try { const sql = neon(process.env.DATABASE_URL!); const result = await sql` INSERT INTO comments (content, username, created_at) VALUES (${comment}, ${twitterHandle}, NOW()) RETURNING * `; return { success: true, data: { text: result[0].content, username: result[0].username } }; } catch (error) { return { success: false, error: \u0026#39;Failed to create comment\u0026#39; }; } } export async function getMessages() { const sql = neon(process.env.DATABASE_URL!); const messages = await sql` SELECT content, username FROM comments ORDER BY created_at DESC `; return messages.map(msg =\u0026gt; ({ text: msg.content, username: msg.username })); } Optional: Create a message list component for your users to write messages # Create a MessageList.tsx file in /components/\nexport default function MessageList({ messages }: MessageListProps) { return ( \u0026lt;div className=\u0026#34;grid grid-cols-3 gap-4\u0026#34;\u0026gt; {[...messages].map((message, index) =\u0026gt; ( \u0026lt;div key={index} className=\u0026#34;p-4 border rounded-lg shadow-sm\u0026#34;\u0026gt; \u0026lt;p className=\u0026#34;break-words mb-2\u0026#34;\u0026gt;{message.text}\u0026lt;/p\u0026gt; \u0026lt;a href={`https://x.com/${message.username}`}\u0026gt; @{message.username} \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ); } Put it all together on the main page # export default function Home() { const { data: session, status } = useSession(); const [messages, setMessages] = useState\u0026lt;{ text: string, username: string }[]\u0026gt;([]); // Load messages on component mount useEffect(() =\u0026gt; { async function fetchMessages() { const fetchedMessages = await getMessages(); setMessages(fetchedMessages); } fetchMessages(); }, []); // Handle message creation async function create(formData: FormData) { const comment = formData.get(\u0026#39;comment\u0026#39;) as string; if (!comment?.trim()) return; const result = await createComment(comment, session?.user?.username || \u0026#39;anonymous\u0026#39;); if (result.success) { setMessages(prev =\u0026gt; [result.data, ...prev]); } } return ( \u0026lt;div\u0026gt; {session ? ( \u0026lt;\u0026gt; \u0026lt;h2\u0026gt;Welcome, {session.user.username}!\u0026lt;/h2\u0026gt; \u0026lt;form onSubmit={(e) =\u0026gt; { e.preventDefault(); create(new FormData(e.currentTarget)); }}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;comment\u0026#34; placeholder=\u0026#34;Write a message\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/\u0026gt; ) : ( \u0026lt;button onClick={() =\u0026gt; signIn(\u0026#39;twitter\u0026#39;)}\u0026gt; Sign in with Twitter \u0026lt;/button\u0026gt; )} \u0026lt;MessageList messages={messages} /\u0026gt; \u0026lt;/div\u0026gt; ); } Make sure your .env.local file is complete # TWITTER_CLIENT_ID=your_twitter_client_id TWITTER_CLIENT_SECRET=your_twitter_client_secret DATABASE_URL=your_neon_database_url NEXTAUTH_SECRET=your_nextauth_secret NEXTAUTH_URL=http://localhost:3000 remember that this file only stores the environment variables locally, and you should put the variables in your hosted environment when you launch.\nNow you should be able to test locally and launch globally (on the world wide www\u0026rsquo;s) your twitter authentication, with some database fun.\n"},{"id":2,"href":"/what-is-icu/","title":"What is ICU?","section":"Tormod's Blog","content":" Stands for International Components for Unicode A set of libraries supporting localisation and internationalisation ICU does a number of things:\nText handling and Unicode Support\nUnicode is a standard encoding system for all the languages in the world. 倪好! Allows software to process characters correctly regardless of language, ex. for applications that need to handle multilingual text. String Comparison and Sorting\nDifferent languages have rules for alphabetising text, and ICU provides functions that sort text according to regional language rules (collation) to make sure words are ordered correctly in each language. "}]